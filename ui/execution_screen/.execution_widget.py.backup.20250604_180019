"""
Widget principal d'ex√©cution de plugins.

Ce module fournit le widget central responsable de l'affichage et de l'ex√©cution
des plugins configur√©s, avec gestion des logs et de la progression.
"""

from typing import Dict, List, Any, Optional, Tuple, Set
import traceback
import sys
import os
import json
import re
import asyncio

from textual.app import ComposeResult, App
from textual.containers import Container, Horizontal, ScrollableContainer, Vertical
from textual.widgets import Button, Checkbox, Label, ProgressBar, Static, Footer, Header
from textual.reactive import reactive
from textual.binding import Binding

from .plugin_container import PluginContainer
from .local_executor import LocalExecutor
from .ssh_executor import SSHExecutor
from .logger_utils import LoggerUtils
from ..utils.messaging import Message, MessageType
from ..choice_screen.plugin_utils import get_plugin_folder_name
from ..utils.logging import get_logger
from ..ssh_manager.ip_utils import get_target_ips

logger = get_logger('execution_widget')

class ExecutionWidget(Container):
    """
    Widget principal d'ex√©cution des plugins.

    Ce widget coordonne l'affichage et l'ex√©cution de tous les plugins configur√©s,
    y compris leur ex√©cution locale ou distante via SSH.
    """

    # √âtats r√©actifs
    is_running = reactive(False)  # √âtat d'ex√©cution
    continue_on_error = reactive(True)  # Continuer m√™me en cas d'erreur (True par d√©faut)
    show_logs = reactive(True)  # Logs visibles par d√©faut
    back_button_clicked = reactive(False)  # Suivi du bouton retour

    def __init__(self, plugins_config: Optional[Dict[str, Any]] = None):
        """
        Initialise le widget avec la configuration des plugins.

        Args:
            plugins_config: Dictionnaire de configuration des plugins
        """
        super().__init__()
        self.plugins: Dict[str, PluginContainer] = {}
        self.plugins_config = plugins_config or {}
        self._current_plugin = None
        self._total_plugins = 0
        self._executed_plugins = 0
        self.sequence_name = None
        self._app_ref = None  # R√©f√©rence √† l'application, d√©finie lors du montage

        # Extraire le nom de la s√©quence si pr√©sent
        self._extract_sequence_name()

        logger.debug(f"ExecutionWidget initialis√© avec {len(self.plugins_config)} plugins")
        logger.debug(f"Plugins disponibles: {list(self.plugins_config.keys())}")

    def _extract_sequence_name(self) -> None:
        """Extrait le nom de la s√©quence depuis la configuration des plugins."""
        for plugin_id, config in self.plugins_config.items():
            plugin_name = config.get('plugin_name', '')
            if isinstance(plugin_name, str) and plugin_name.startswith('__sequence__'):
                sequence_file = plugin_name.replace('__sequence__', '')
                self.sequence_name = sequence_file.replace('.yml', '')
                logger.debug(f"S√©quence d√©tect√©e: {self.sequence_name}")
                break

    async def execute_plugin(self, plugin_id: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Ex√©cute un plugin sp√©cifique localement ou via SSH.

        Args:
            plugin_id: Identifiant du plugin √† ex√©cuter
            config: Configuration du plugin

        Returns:
<<<<<<< found
            Dict[str, Any]: R√©sultat de l'ex√©cution {success, output}
        """
        try:
||||||| expected
            Tuple[bool, str]: (succ√®s, sortie)
        """
        try:
            logger.info(f"Ex√©cution locale du plugin {folder_name}")

=======
            Tuple[bool, str]: (succ√®s, sortie)
        """
        # Validation des param√®tres d'entr√©e
        if not folder_name:
            error_msg = "Nom de dossier du plugin manquant"
            logger.error(error_msg)
            return False, error_msg
        
        if not isinstance(config, dict):
            logger.warning("Configuration du plugin invalide, utilisation d'une configuration vide")
            config = {}

        try:
            logger.info(f"Ex√©cution locale du plugin {folder_name}")

>>>>>>> replacement
            # V√©rifier si la configuration est valide
            if not config:
                logger.warning(f"Configuration vide pour {plugin_id}")
            
            if not isinstance(config, dict):
                logger.error(f"Configuration invalide pour {plugin_id}: {config}")
                return {
                    'success': False,
                    'output': f"Erreur: Configuration invalide pour le plugin {plugin_id}"
                }

            # Extraire les informations de base
            plugin_name = self._get_plugin_name(plugin_id, config)
            
            # Validation du nom du plugin
            if not plugin_name:
                return False, f"Nom de plugin invalide pour {plugin_id}"
            plugin_name = self._get_plugin_name(plugin_id, config)
            plugin_config = self._extract_plugin_config(config)
            instance_id = config.get('instance_id', plugin_id)
            show_name = config.get('show_name', config.get('name', plugin_name))
            icon = config.get('icon', 'üì¶')

            # Ignorer les s√©quences
            if isinstance(plugin_name, str) and plugin_name.startswith('__sequence__'):
                logger.debug(f"S√©quence ignor√©e: {plugin_name}")
                return True, "S√©quence ignor√©e"
            
            # Validation du nom du dossier
            if not folder_name:
                logger.warning(f"Tentative d'ex√©cution d'une s√©quence: {plugin_name}")
                return False

            # R√©cup√©rer le dossier du plugin
            folder_name = get_plugin_folder_name(plugin_name)
            logger.debug(f"Dossier du plugin {plugin_name} (ID: {instance_id}): {folder_name}")
            logger.debug(f"Configuration: {plugin_config}")

            # D√©terminer le mode d'ex√©cution (local ou SSH)
            remote_execution = config.get('remote_execution', False)
            logger.debug(f"Mode d'ex√©cution pour {plugin_id}: {'SSH' if remote_execution else 'Local'}")
            
            # Validation suppl√©mentaire pour SSH
            if remote_execution and not plugin_config.get('ssh_ips'):
                logger.warning(f"Plugin SSH {plugin_id} sans IPs configur√©es")
            
            executor = self._create_executor(plugin_id, folder_name, plugin_config, remote_execution)

            # Ex√©cuter le plugin
            plugin_widget = self.plugins.get(plugin_id)
            status = await executor.execute_plugin(plugin_widget, folder_name, config)

            return status


        except Exception as e:
            logger.error(f"Erreur lors de l'ex√©cution du plugin {plugin_id}: {e}")
            logger.error(traceback.format_exc())

            # Ajouter des informations sur l'IP cible en cas d'erreur SSH
            plugin_widget = self.plugins.get(plugin_id)
            target_ip = getattr(plugin_widget, 'target_ip', None) if plugin_widget else None

            # Log avec IP si disponible
            error_msg = str(e)
            if target_ip:
                logger.error(f"Erreur sur {target_ip}: {error_msg}")
                output_msg = f"Erreur d'ex√©cution sur {target_ip}: {error_msg}"
            else:
                output_msg = f"Erreur d'ex√©cution: {error_msg}"

            return False

    def _get_plugin_name(self, plugin_id: str, config: Dict[str, Any]) -> str:
        """
        D√©termine le nom du plugin √† partir de sa configuration.

        Args:
            plugin_id: Identifiant du plugin
            config: Configuration du plugin

        Returns:
            str: Nom du plugin
        """
        plugin_name = config.get('plugin_name', '')
        if not plugin_name:
            # Si pas de nom, utiliser le dossier comme nom
            plugin_name = get_plugin_folder_name(str(plugin_id))
            logger.debug(f"Utilisation du dossier comme nom: {plugin_name}")
        return plugin_name

    def _extract_plugin_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extrait la configuration effective du plugin.

        Args:
            config: Configuration compl√®te

        Returns:
            Dict[str, Any]: Configuration nettoy√©e
        """
        # Si une cl√© 'config' existe, l'utiliser
        if 'config' in config:
            plugin_config = config['config']
            if not isinstance(plugin_config, dict):
                logger.warning(f"Configuration 'config' invalide, utilisation d'un dictionnaire vide")
                return {}
            return config['config']

        # Sinon, copier toutes les cl√©s sauf celles sp√©ciales
        special_keys = {'plugin_name', 'instance_id', 'show_name', 'icon', 'remote_execution'}
        return {k: v for k, v in config.items() if k not in special_keys}

    def _create_executor(self, plugin_id: str, folder_name: str,
                        plugin_config: Dict[str, Any], remote_execution: bool) -> Any:
        """
        Cr√©e l'ex√©cuteur appropri√© (local ou SSH) pour le plugin.

        Args:
            plugin_id: Identifiant du plugin
            folder_name: Nom du dossier du plugin
            plugin_config: Configuration du plugin
            remote_execution: Si True, utilise l'ex√©cution SSH

        Returns:
            Any: Ex√©cuteur configur√©
        """
        if remote_execution:
            logger.debug(f"Cr√©ation d'un ex√©cuteur SSH pour {plugin_id}")
            
            # Validation pour l'ex√©cution SSH
            if not plugin_config:
                logger.warning(f"Configuration vide pour l'ex√©cuteur SSH {plugin_id}")
                plugin_config = {}
            # Configuration pour l'ex√©cuteur SSH
            ssh_config = {
                'plugin_name': folder_name,
                'instance_id': plugin_id.split('_')[-1] if '_' in plugin_id else plugin_id,
                'config': plugin_config,
                'ssh_debug': plugin_config.get('ssh_debug', False)
            }
            
            # Validation de la configuration SSH
            if not ssh_config.get('plugin_name'):
                logger.error(f"Nom de plugin manquant pour l'ex√©cuteur SSH {plugin_id}")
            return SSHExecutor(ssh_config)
        else:
            logger.debug(f"Cr√©ation d'un ex√©cuteur local pour {plugin_id}")
            return LocalExecutor(self.app if self._app_ref is None else self._app_ref)

    async def run_plugins(self) -> None:
        """
        Ex√©cute tous les plugins de fa√ßon s√©quentielle.

        Cette m√©thode est le c≈ìur du processus d'ex√©cution, g√©rant l'ordre,
        les erreurs et la mise √† jour de l'interface.
        """
        try:
            await LoggerUtils.start_logs_timer(self)
            # Pr√©parer l'ex√©cution
            filtered_plugins, filtered_configs, ordered_plugins = self._prepare_plugins_execution()

            # V√©rification de la pr√©paration
            if not ordered_plugins:
                await LoggerUtils.add_log(self, "Aucun plugin √† ex√©cuter", level="warning")
                return

            total_plugins = len(ordered_plugins)
            executed = 0

            # Initialiser l'interface
            self._initialize_execution_ui()
            await LoggerUtils.add_log(self, f"D√©marrage de l'ex√©cution de {total_plugins} plugins", level="info")

            # Ex√©cuter chaque plugin dans l'ordre
            for plugin_id in ordered_plugins:
                # V√©rification de la continuit√© de l'ex√©cution
                if not self.is_running:
                    logger.info("Ex√©cution arr√™t√©e par l'utilisateur")
                    await LoggerUtils.add_log(self, "Ex√©cution interrompue par l'utilisateur", level="warning")
                    break

                # Double v√©rification de l'√©tat d'ex√©cution
                if not self.is_running:
                    logger.info("Ex√©cution arr√™t√©e par l'utilisateur")
                    break

                # R√©cup√©rer le plugin et sa configuration
                plugin_widget = filtered_plugins[plugin_id]
                config = filtered_configs[plugin_id]
                plugin_name = plugin_widget.plugin_name

                # Validation du plugin et de sa configuration
                if not plugin_widget:
                    logger.error(f"Widget manquant pour {plugin_id}")
                    continue
                if not config:
                    logger.error(f"Configuration manquante pour {plugin_id}")
                    continue

                # Mettre √† jour l'interface
                self.set_current_plugin(plugin_name)
                self.update_global_progress(executed / total_plugins * 100)

                try:
                    # Initialiser la progression
                    plugin_widget.update_progress(0.0, "En cours")

                    # Log de d√©but d'ex√©cution avec contexte
                    target_ip = getattr(plugin_widget, 'target_ip', None)
                    remote_execution = config.get('remote_execution', False)
                    
                    exec_type = "SSH" if remote_execution else "Local"
                    exec_details = f" sur {target_ip}" if target_ip else ""
                    await LoggerUtils.add_log(
                        self, 
                        f"D√©but ex√©cution {exec_type}{exec_details}: {plugin_name}", 
                        level="info"
                    )

                    # Ex√©cuter le plugin
                    logger.debug(f"Ex√©cution du plugin {plugin_id}")
                    result = await self.execute_plugin(plugin_id, config)

                    # Log de fin d'ex√©cution
                    status_msg = "r√©ussie" if result else "√©chou√©e"
                    await LoggerUtils.add_log(
                        self, 
                        f"Ex√©cution {status_msg}{exec_details}: {plugin_name}", 
                        level="success" if result else "error"
                    )

                    # Mise √† jour du statut bas√©e sur le r√©sultat
                    # Mise √† jour du statut et de la sortie
                    self._update_plugin_status(plugin_widget, result)



                except Exception as e:
                    logger.error(f"Erreur lors de l'ex√©cution de {plugin_id}: {e}")
                    logger.error(traceback.format_exc())

                    # Mise √† jour du statut du plugin en cas d'erreur
                    plugin_widget.set_status("error")
                    plugin_widget.set_output(f"Erreur")
                    plugin_widget.update_progress(100.0, "Erreur")

                    # Si on ne continue pas en cas d'erreur, arr√™ter l'ex√©cution
                    if not self.continue_on_error:
                        logger.warning(f"Arr√™t de l'ex√©cution apr√®s erreur sur {plugin_id}")
                        break

                executed += 1
                self.update_global_progress(executed / total_plugins * 100)

            # Afficher un message de fin d'ex√©cution
            self._display_execution_summary(executed, total_plugins)

        except Exception as e:
            logger.error(f"Erreur globale lors de l'ex√©cution: {e}")
            logger.error(traceback.format_exc())
            await LoggerUtils.add_log(self, f"Erreur lors de l'ex√©cution: {e}", level="error")
        finally:
            # Arr√™ter le timer d'affichage des logs
            await LoggerUtils.stop_logs_timer()

            # Afficher un dernier lot de messages en attente
            await LoggerUtils.flush_pending_messages(self)

    def _prepare_plugins_execution(self) -> Tuple[Dict[str, Any], Dict[str, Any], List[str]]:
        """
        Pr√©pare les plugins pour l'ex√©cution en filtrant les s√©quences.

        Returns:
            Tuple: (plugins_filtr√©s, configs_filtr√©es, ordre_ex√©cution)
        """
        # Identifier les plugins de s√©quence
        filtered_plugins = {}
        filtered_configs = {}
        sequence_plugin_ids = []

        # Identifier les plugins de s√©quence principaux
        for plugin_id, config in self.plugins_config.items():
            plugin_name = config.get('plugin_name', '')
            if isinstance(plugin_name, str) and plugin_name.startswith('__sequence__'):
                sequence_plugin_ids.append(plugin_id)
                logger.debug(f"S√©quence principale identifi√©e: {plugin_id}")

        # Cr√©er une liste ordonn√©e pour l'ex√©cution
        ordered_plugins = []

        # Filtrer les plugins et cr√©er l'ordre d'ex√©cution
        for plugin_id, plugin in self.plugins.items():
            # Ignorer les s√©quences principales
            if plugin_id in sequence_plugin_ids:
                logger.debug(f"S√©quence ignor√©e: {plugin_id}")
                continue

            if plugin_id in sequence_plugin_ids:
                continue

            # V√©rifier si la configuration existe
            if plugin_id in self.plugins_config:
                filtered_plugins[plugin_id] = plugin
                filtered_configs[plugin_id] = self.plugins_config[plugin_id]
                
                # Validation suppl√©mentaire de la configuration
                config = self.plugins_config[plugin_id]
                if not isinstance(config, dict):
                    logger.warning(f"Configuration invalide pour {plugin_id}, ignor√©")
                    continue
                ordered_plugins.append(plugin_id)
                logger.debug(f"Plugin ajout√©: {plugin_id}")
            else:
                logger.warning(f"Configuration manquante pour {plugin_id}")

        logger.debug(f"Pr√©paration termin√©e: {len(ordered_plugins)} plugins √† ex√©cuter")
        return filtered_plugins, filtered_configs, ordered_plugins

    def _initialize_execution_ui(self) -> None:
        """Initialise l'interface pour l'ex√©cution."""
        # S'assurer que les logs sont visibles
        logs_container = self.query_one("#logs-container", ScrollableContainer)
        if logs_container and "hidden" in logs_container.classes:
            logs_container.remove_class("hidden")
            self.show_logs = True

    def _update_plugin_status(self, plugin_widget: PluginContainer,
                             status) -> None:
        """
        Met √† jour le statut et la sortie d'un plugin apr√®s ex√©cution.

        Args:
            plugin_widget: Widget du plugin
        """
        statusValue,statusText=status
        try:
            # Mettre √† jour le statut
            if statusValue:
                plugin_widget.set_status("success")
                plugin_widget.set_output("OK")
            else:
                plugin_widget.set_status("error")
                plugin_widget.set_output("Erreur")
            # Mettre √† jour la sortie

            # Mettre √† jour la progression
            plugin_widget.update_progress(100.0, "Termin√©" if statusValue else "√âchec")
        except Exception as e:
            logger.error(f"Erreur lors de la mise √† jour du statut: {e}")


    async def _display_execution_summary(self, executed: int, total: int) -> None:
        """
        Affiche un r√©sum√© de l'ex√©cution dans les logs.

        Args:
            executed: Nombre de plugins ex√©cut√©s
            total: Nombre total de plugins
        """
        # V√©rifier s'il y a eu des erreurs
        has_errors = False
        for plugin_id, plugin_widget in self.plugins.items():
            if plugin_widget.status == "error":
                has_errors = True
                break

        # D√©terminer le niveau de log
        if has_errors:
            level = "error"
        elif executed < total:
            level = "warning"
        else:
            level = "success"

        # Construire le message
        texte_plugin = "plugins ex√©cut√©s" if executed > 1 else "plugin ex√©cut√©"
        message = f"Ex√©cution termin√©e : {executed}/{total} {texte_plugin}"

        if has_errors:
            message += " (des erreurs ont √©t√© d√©tect√©es)"
        elif executed < total:
            message += " (certains plugins n'ont pas √©t√© ex√©cut√©s)"

        await LoggerUtils.add_log(self, message, level=level)

    async def start_execution(self, auto_mode: bool = False) -> None:
        """
        D√©marre l'ex√©cution des plugins.

        Args:
            auto_mode: Si True, l'ex√©cution est lanc√©e automatiquement
        """
        # V√©rifier si une ex√©cution est d√©j√† en cours
        if self.is_running:
            logger.debug("Une ex√©cution est d√©j√† en cours")
            return

        # R√©cup√©rer les boutons
        start_button = self.query_one("#start-button")
        back_button = self.query_one("#back-button")
        if not start_button:
            logger.error("Bouton de d√©marrage introuvable")
            return

        try:
            # D√©marrer l'ex√©cution
            logger.info(f"D√©marrage de l'ex√©cution - Plugins: {len(self.plugins_config)}")
            
            # Validation avant d√©marrage
            if not self.plugins_config:
                logger.error("Aucune configuration disponible pour l'ex√©cution")
                return
            self.is_running = True
            logger.info("D√©marrage de l'ex√©cution")

            # Masquer les boutons pendant l'ex√©cution
            start_button.add_class("hidden")
            back_button.add_class("hidden")
            logger.debug("Boutons masqu√©s")

            # R√©initialiser l'interface
            self.update_global_progress(0)
            self.logs_text.update("")
            self.logs_text.auto_refresh=True
            await LoggerUtils.clear_logs(self)

            # Ex√©cuter les plugins
            await self.run_plugins()

            # V√©rification post-ex√©cution
            if self.is_running:
                await LoggerUtils.add_log(self, "Ex√©cution termin√©e normalement", level="success")
            else:
                await LoggerUtils.add_log(self, "Ex√©cution interrompue", level="warning")

            # Notifier la fin de l'ex√©cution
            logger.debug("Notification de fin d'ex√©cution")
            if hasattr(self.app.screen, 'on_execution_completed'):
                await self.app.screen.on_execution_completed()

            # R√©afficher les boutons apr√®s l'ex√©cution si pas en mode auto
            if not auto_mode:
                # Attendre un d√©lai avant de r√©afficher pour √©viter les clics accidentels
                await asyncio.sleep(0.5)
                start_button.remove_class("hidden")
                back_button.remove_class("hidden")
                logger.debug("Boutons r√©affich√©s apr√®s ex√©cution")

            try:
                await LoggerUtils.flush_pending_messages(self.app)
                # Force un second flush apr√®s une courte pause
                await asyncio.sleep(0.1)
                await LoggerUtils.flush_pending_messages(self.app)
                # Rafra√Æchir l'UI apr√®s le flush
                self.refresh()
            except Exception as e:
                logger.error(f"Erreur lors du flush final des logs: {e}")


        except Exception as e:
            logger.error(f"Erreur lors du d√©marrage de l'ex√©cution: {e}")
            logger.error(traceback.format_exc())

            # Afficher un message d'erreur
            error_msg = Message(
                type=MessageType.ERROR,
                content=f"Erreur lors du d√©marrage: {e}"
            )
            await LoggerUtils.display_message(self, error_msg)

            # R√©afficher les boutons en cas d'erreur
            start_button.remove_class("hidden")
            back_button.remove_class("hidden")

        finally:
            self.is_running = False
            self.back_button_clicked = False



    def update_global_progress(self, progress: float) -> None:
        """
        Met √† jour la barre de progression globale.

        Args:
            progress: Valeur de progression (0-100)
        """
        try:
            # Essayer de trouver la barre de progression
            progress = max(0.0, min(100.0, float(progress)))  # Validation des valeurs
            
            try:
                progress_bar = self.query_one("#global-progress")
                if progress_bar:
                    progress_bar.update(total=100.0, progress=progress)
                    logger.debug(f"Progression mise √† jour: {progress}%")
            except Exception as e:
                logger.debug(f"Barre de progression non trouv√©e: {e}")

                # Essayer de la cr√©er si elle n'existe pas
                button_container = self.query_one("#button-container")
                if button_container:
                    # V√©rifier si elle existe d√©j√†
                    existing_bars = [w for w in button_container.children
                                    if getattr(w, "id", "") == "global-progress"]
                    if existing_bars:
                        existing_bars[0].update(total=100.0, progress=progress)
                    else:
                        # Cr√©er une nouvelle barre
                        from textual.widgets import ProgressBar
                        new_bar = ProgressBar(id="global-progress", show_eta=False)
                        new_bar.total = 100.0
                        new_bar.progress = progress
                        button_container.mount(new_bar)
                        logger.debug("Nouvelle barre de progression cr√©√©e")
        except Exception as e:
            logger.error(f"Impossible de mettre √† jour la progression: {e}")

    def set_current_plugin(self, plugin_name: str) -> None:
        """
        Met √† jour l'affichage du plugin courant et scrolle vers lui.

        Args:
            plugin_name: Nom du plugin en cours d'ex√©cution
        """
        try:
            # Scroller vers le plugin en cours
            if plugin_name != "aucun":
                try:
                    plugins_list = self.query_one("#plugins-list")
                    if plugins_list:
                        for plugin_id, plugin in self.plugins.items():
                            if plugin.plugin_name == plugin_name:
                                # Scroller vers le plugin
                                plugin.scroll_visible()
                                break
                except Exception as e:
                    logger.debug(f"Impossible de scroller vers {plugin_name}: {e}")
        except Exception as e:
            logger.error(f"Erreur lors de la mise √† jour du plugin courant: {e}")

    def action_toggle_logs(self) -> None:
        """Affiche ou masque les logs."""
        LoggerUtils.toggle_logs(self)

    async def display_log(self, message: str, level: str = "info") -> None:
        """
        Affiche un message dans les logs (compatibilit√© avec anciens syst√®mes).

        Args:
            message: Message √† afficher
            level: Niveau du message (info, warning, error, success)
        """
        await LoggerUtils.add_log(self, message, level)

    def sanitize_id(self, id_string: str) -> str:
        """
        Assainit une cha√Æne pour l'utiliser comme ID en supprimant les caract√®res invalides.

        Args:
            id_string: Cha√Æne √† assainir

        Returns:
            str: Cha√Æne assainie
        """
        return ''.join(c if c.isalnum() or c in '-_' else '_' for c in id_string)

    def _create_ssh_plugin_containers(self, plugin_id: str, config: Dict[str, Any],
                                    plugin_name: str, show_name: str, icon: str) -> List[str]:
        """
        Cr√©e des conteneurs pour un plugin SSH avec plusieurs IPs.

        Args:
            plugin_id: ID du plugin
            config: Configuration du plugin
            plugin_name: Nom du plugin
            show_name: Nom √† afficher
            icon: Ic√¥ne du plugin

        Returns:
            List[str]: Liste des IDs de conteneurs cr√©√©s
        """
        created_containers = []
        plugin_config = config.get('config', {})
        
        # Validation de la configuration
        if not isinstance(plugin_config, dict):
            logger.warning(f"Configuration du plugin {plugin_id} invalide pour SSH multi-IP")
            plugin_config = {}
        
        ssh_ips = plugin_config.get('ssh_ips', '')
        ssh_exception_ips = plugin_config.get('ssh_exception_ips', '')
        
        logger.debug(f"SSH IPs pour {plugin_id}: {ssh_ips}")
        logger.debug(f"SSH Exception IPs pour {plugin_id}: {ssh_exception_ips}")

        # Si le plugin a plusieurs IPs
        if ssh_ips and ('*' in ssh_ips or ',' in ssh_ips):
            # Obtenir la liste des IPs cibles
            target_ips = get_target_ips(ssh_ips, ssh_exception_ips)
            logger.debug(f"Plugin SSH {plugin_id} avec {len(target_ips)} IPs: {target_ips}")

            if target_ips:
                # Cr√©er un conteneur pour chaque IP
                for ip in target_ips:
                    # Cr√©er un ID unique
                    ip_plugin_id = f"{plugin_id}_{ip.replace('.', '_')}"

                    # V√©rifier si ce conteneur existe d√©j√†
                    if ip_plugin_id in self.plugins:
                        logger.debug(f"Conteneur d√©j√† existant pour {ip_plugin_id}")
                        continue

                    # Assainir l'ID
                    sanitized_id = self.sanitize_id(ip_plugin_id)

                    # Cr√©er le conteneur avec l'IP dans le nom
                    ip_show_name = f"{show_name} ({ip})"
                    container = PluginContainer(sanitized_id, plugin_name, ip_show_name, icon)

                    # Stocker l'IP cible
                    container.target_ip = ip

                    # Ajouter aux plugins
                    self.plugins[ip_plugin_id] = container

                    # Cr√©er une copie de la configuration pour cette IP
                    ip_config = config.copy()
                    self.plugins_config[ip_plugin_id] = ip_config

                    logger.debug(f"Conteneur ajout√© pour {ip_plugin_id}: {ip_show_name}")
                    created_containers.append(ip_plugin_id)

                    yield container
            else:
                # Aucune IP valide, cr√©er un conteneur d'erreur
                if plugin_id not in self.plugins:
                    sanitized_id = self.sanitize_id(plugin_id)
                    container = PluginContainer(sanitized_id, plugin_name,
                                              f"{show_name} (Aucune IP valide)", icon)
                    self.plugins[plugin_id] = container
                    logger.debug(f"Conteneur d'erreur ajout√© pour {plugin_id}")
                    created_containers.append(plugin_id)

                    yield container

        return created_containers

    def compose(self) -> ComposeResult:
        """
        Compose l'interface du widget d'ex√©cution.

        Returns:
            ComposeResult: R√©sultat de la composition
        """
        # En-t√™te avec le nom de la s√©quence si disponible
        header_text = "Ex√©cution des plugins"
        if self.sequence_name:
            header_text = f"Ex√©cution de la s√©quence: {self.sequence_name}"
        yield Header(name=header_text)

        # Liste des plugins
        with ScrollableContainer(id="plugins-list"):
            logger.debug(f"Cr√©ation des conteneurs pour {len(self.plugins_config)} plugins")
            processed_plugins = set()

            # Copie du dictionnaire pour √©viter les erreurs de taille
            plugins_config_copy = self.plugins_config.copy()

            for plugin_id, config in plugins_config_copy.items():
                # Ignorer les s√©quences
                plugin_name = config.get('plugin_name', '')
                if isinstance(plugin_name, str) and plugin_name.startswith('__sequence__'):
                    logger.debug(f"Ignor√© s√©quence: {plugin_name}")
                    continue

                # V√©rifier si d√©j√† trait√©
                if plugin_id in processed_plugins:
                    logger.debug(f"Plugin {plugin_id} d√©j√† trait√©")
                    continue

                processed_plugins.add(plugin_id)

                # R√©cup√©rer les informations du plugin
                if not plugin_name:
                    plugin_name = get_plugin_folder_name(str(plugin_id))

                show_name = config.get('name', plugin_name)
                icon = config.get('icon', 'üì¶')

                # Cr√©er le conteneur avec ID unique
                plugin_container = PluginContainer(
                    plugin_id=plugin_id,
                    plugin_name=plugin_name,
                    plugin_show_name=show_name,
                    plugin_icon=icon
                )

                # V√©rifier que le conteneur a √©t√© cr√©√© correctement
                if plugin_container.id:
                    self.plugins[plugin_id] = plugin_container
                    yield plugin_container
                else:
                    logger.error(f"Impossible de cr√©er un conteneur pour {plugin_id}")

                # Cr√©er des conteneurs suppl√©mentaires pour SSH multi-IPs
                plugin_config = config.get('config', {})
                ssh_ips = plugin_config.get('ssh_ips', '')

                if ssh_ips and ('*' in ssh_ips or ',' in ssh_ips):
                    yield from self._create_ssh_plugin_containers(
                        plugin_id, config, plugin_name, show_name, icon
                    )
                elif ssh_ips:
                    # Plugin SSH avec une seule IP
                    if plugin_id not in self.plugins:
                        sanitized_id = self.sanitize_id(plugin_id)
                        container = PluginContainer(sanitized_id, plugin_name, show_name, icon)
                        container.target_ip = ssh_ips.strip()
                        self.plugins[plugin_id] = container
                        logger.debug(f"Conteneur SSH simple ajout√© pour {plugin_id}")
                        yield container

        # Zone des logs
        with Horizontal(id="logs"):
            with ScrollableContainer(id="logs-container", classes=""):
                self.logs_text = Static("", id="logs-text")
                yield self.logs_text

        # Boutons et contr√¥les
        with Horizontal(id="button-container"):
            with Vertical(id="button-container-back-exec"):
                yield Button("Retour", id="back-button", variant="error")
            with Vertical(id="button-container-continue-exec"):
                yield Checkbox("Continuer en cas d'erreur", id="continue-on-error", value=True)
            # Initialiser la barre de progression avec des valeurs par d√©faut
            with Vertical(id="button-container-progress-exec"):
                progress_bar = ProgressBar(id="global-progress", show_eta=False)
                progress_bar.total = 100.0
                yield progress_bar
            # Bouton de d√©marrage
            with Vertical(id="button-container-start-exec"):
                yield Button("D√©marrer", id="start-button", variant="primary")

        yield Footer()

    async def on_mount(self) -> None:
        """
        Appel√© au montage initial du widget.
        Initialise l'interface et les r√©f√©rences.
        """
        # R√©cup√©rer la r√©f√©rence √† l'application
        self._app_ref = self.app
        logger.debug(f"ExecutionWidget mont√©, app={self._app_ref}")

        # Initialiser l'interface apr√®s rafra√Æchissement
        self.call_after_refresh(self.initialize_ui)

    async def initialize_ui(self) -> None:
        """Initialise l'interface apr√®s le montage complet du DOM."""
        try:
            # Initialisation de base
            self.update_global_progress(0)

            # S'assurer que les logs sont visibles
            logs_container = self.query_one("#logs-container", ScrollableContainer)
            if logs_container and "hidden" in logs_container.classes:
                logs_container.remove_class("hidden")
                self.show_logs = True

            # G√©rer l'affichage du bouton d√©marrer
            start_button = self.query_one("#start-button")
            if start_button and self.back_button_clicked:
                start_button.remove_class("hidden")
                logger.debug("Bouton d√©marrer affich√©")

            # Initialiser les options
            self.continue_on_error = True  # True par d√©faut

            # Vider les logs
            await LoggerUtils.clear_logs(self)

            # IMPORTANT: Afficher les messages en attente maintenant que l'interface est pr√™te
            # Ajouter un d√©lai court pour s'assurer que l'interface est compl√®tement rendue
            await asyncio.sleep(0.1)
            await LoggerUtils.flush_pending_messages(self)

        except Exception as e:
            logger.error(f"Erreur lors de l'initialisation de l'interface: {e}")
            logger.error(traceback.format_exc())

    async def on_checkbox_changed(self, event: Checkbox.Changed) -> None:
        """
        G√®re le changement d'√©tat des cases √† cocher.

        Args:
            event: √âv√©nement de changement
        """
        if event.checkbox.id == "continue-on-error":
            self.continue_on_error = event.value
            logger.debug(f"Option 'continuer en cas d'erreur' chang√©e: {self.continue_on_error}")

    async def on_button_pressed(self, event: Button.Pressed) -> None:
        """
        G√®re les clics sur les boutons.

        Args:
            event: √âv√©nement de bouton press√©
        """
        button_id = event.button.id
        logger.debug(f"Clic sur le bouton {button_id}")

        if not button_id:
            logger.warning("Bouton sans identifiant d√©tect√©")
            return

        try:
            if button_id == "start-button" and not event.button.disabled:
                # D√©marrer l'ex√©cution
                await self.start_execution()
            elif button_id == "back-button":
                # Marquer que le bouton retour a √©t√© cliqu√©
                self.back_button_clicked = True
                logger.debug("Retour √† l'√©cran de configuration")

                await self._return_to_config_screen()
            elif button_id == "toggle-logs-button":
                # Afficher/masquer les logs
                self.action_toggle_logs()
        except Exception as e:
            logger.error(f"Erreur lors du traitement du clic sur {button_id}: {e}")
            logger.error(traceback.format_exc())
            # En cas d'erreur, r√©activer le bouton
            if button_id == "start-button":
                event.button.disabled = False

    async def _return_to_config_screen(self) -> None:
        """
        Retourne √† l'√©cran de configuration en pr√©servant les configurations.
        """
        try:
            # Import ici pour √©viter les imports circulaires
            from ..config_screen.config_screen import PluginConfig

            # Extraire les infos de plugin pour l'√©cran de configuration
            plugin_instances = []

            for plugin_id in self.plugins_config.keys():
                # R√©cup√©rer la configuration
                config = self.plugins_config.get(plugin_id, {})
                if not isinstance(config, dict):
                    continue

                # Ignorer les s√©quences
                plugin_name = config.get('plugin_name', '')
                if isinstance(plugin_name, str) and plugin_name.startswith('__sequence__'):
                    continue

                try:
                    # R√©cup√©rer le dossier du plugin
                    folder_name = get_plugin_folder_name(plugin_name)
                    # Utiliser l'instance ID de la configuration
                    instance_id = config.get('instance_id', 0)
                    # Ajouter le tuple (nom_plugin, instance_id)
                    plugin_instances.append((folder_name, instance_id))
                    logger.debug(f"Plugin ajout√© pour retour: {folder_name}_{instance_id}")
                except Exception as e:
                    logger.error(f"Erreur lors de l'extraction des infos pour {plugin_id}: {e}")

            # Cr√©er l'√©cran de configuration
            config_screen = PluginConfig(plugin_instances)

            # Pr√©parer les configurations pour l'√©cran de config
            corrected_config = self._prepare_configs_for_return(self.plugins_config)

            # Pr√©server la configuration
            config_screen.current_config = corrected_config
            logger.debug(f"Configuration pr√©serv√©e: {len(corrected_config)} plugins")

            # Indiquer qu'on revient de l'√©cran d'ex√©cution
            config_screen.returning_from_execution = True

            # Revenir √† l'√©cran de configuration
            self.app.switch_screen(config_screen)
        except Exception as e:
            logger.error(f"Erreur lors du retour √† l'√©cran de configuration: {e}")
            logger.error(traceback.format_exc())
            self.notify("Erreur lors du retour √† la configuration", severity="error")

    def _prepare_configs_for_return(self, plugins_config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Pr√©pare les configurations pour le retour √† l'√©cran de configuration.

        Args:
            plugins_config: Configurations des plugins

        Returns:
            Dict[str, Any]: Configurations corrig√©es
        """
        corrected_config = {}

        for plugin_id, plugin_data in plugins_config.items():
            # Ignorer les s√©quences
            if isinstance(plugin_id, str) and plugin_id.startswith('__sequence__'):
                continue

            try:
                # Si d√©j√† au bon format, l'utiliser directement
                if isinstance(plugin_data, dict) and 'config' in plugin_data:
                    corrected_config[plugin_id] = plugin_data
                else:
                    # Reconstruire la structure
                    parts = plugin_id.split('_')
                    plugin_name = parts[0]
                    instance_id = int(parts[-1]) if parts[-1].isdigit() else 0

                    # R√©cup√©rer les param√®tres du plugin
                    plugin_folder = get_plugin_folder_name(plugin_name)
                    settings_path = os.path.join(
                        os.path.dirname(__file__), '..', '..', 'plugins',
                        plugin_folder, 'settings.yml'
                    )

                    plugin_settings = {}
                    try:
                        with open(settings_path, 'r', encoding='utf-8') as f:
                            from ruamel.yaml import YAML
                            yaml = YAML()
                            plugin_settings = yaml.load(f)
                    except Exception as e:
                        logger.error(f"Erreur lors du chargement des param√®tres pour {plugin_id}: {e}")

                    remote_execution = plugin_data.get('remote_execution', False)

                    corrected_config[plugin_id] = {
                        'plugin_name': plugin_name,
                        'instance_id': instance_id,
                        'name': plugin_settings.get('name', plugin_name),
                        'show_name': plugin_settings.get('name', plugin_name),
                        'icon': plugin_settings.get('icon', 'üì¶'),
                        'config': plugin_data,
                        'remote_execution': remote_execution
                    }
            except Exception as e:
                logger.error(f"Erreur lors de la correction de config pour {plugin_id}: {e}")

        return corrected_config