#!/usr/bin/env python3
"""
Module utilitaire pour la gestion complète des fichiers de configuration et préférences
des applications Mozilla (Firefox, Thunderbird).
Fournit des fonctionnalités avancées pour lire, écrire et manipuler les fichiers prefs.js,
user.js, mozilla.cfg, policies.json et autres fichiers de configuration.
"""

from plugins_utils.config_files import ConfigFileCommands
from pathlib import Path
import os
import re
import json
import shutil
import configparser
import uuid
from typing import Union, Optional, Dict, List, Any, Tuple


class MozillaPrefsCommands(ConfigFileCommands):
    """
    Classe pour manipuler les fichiers de préférences Mozilla (Firefox, Thunderbird).
    Hérite de ConfigFileCommands pour réutiliser ses fonctionnalités de base.
    Gère les fichiers prefs.js, user.js, mozilla.cfg, policies.json et autres configurations.
    """

    def __init__(self, logger=None, target_ip=None):
        """
        Initialise le gestionnaire de fichiers de préférences Mozilla.

        Args:
            logger: Logger à utiliser
            target_ip: IP cible (pour les opérations à distance)
        """
        super().__init__(logger, target_ip)
        self._pref_cache = {}  # Cache pour les préférences

    def read_prefs_file(self, path: Union[str, Path], log_levels: Optional[Dict[str, str]] = None) -> Optional[Dict[str, Any]]:
        """
        Lit un fichier de préférences Mozilla (prefs.js ou user.js).
        Utilise une analyse plus précise pour préserver le formatage exact.
        """
        file_path = Path(path) if isinstance(path, str) else path
        self.log_debug(f"Lecture du fichier de préférences: {file_path}", log_levels=log_levels)

        # Vérifier si les préférences sont déjà en cache
        cache_key = str(file_path)
        if cache_key in self._pref_cache:
            self.log_debug(f"Utilisation des préférences en cache pour {file_path}", log_levels=log_levels)
            return self._pref_cache[cache_key].copy()

        # Lire le contenu du fichier
        content = self._read_file_content(file_path)
        if content is None:
            return None

        preferences = {}
        # Utiliser une expression régulière plus précise
        pref_pattern = re.compile(r'user_pref\("([^"]+)",\s*(.*?)\);')

        for match in pref_pattern.finditer(content):
            key = match.group(1)
            value_str = match.group(2).strip()

            # Stocker la valeur exacte telle qu'elle apparaît dans le fichier
            if value_str.startswith('"') and value_str.endswith('"'):
                # Préserver la valeur exacte de la chaîne (avec ses échappements)
                raw_string = value_str[1:-1]
                preferences[key] = {"_raw_value": True, "value": raw_string}
            else:
                # Pour les non-chaînes (booléens, nombres, etc.)
                try:
                    preferences[key] = self._convert_pref_value(value_str)
                except Exception as e:
                    self.log_warning(f"Erreur lors de la conversion de la valeur pour {key}: {e}", log_levels=log_levels)
                    preferences[key] = value_str

        # Mettre en cache les préférences lues
        self._pref_cache[cache_key] = preferences.copy()
        self.log_debug(f"Fichier de préférences lu: {len(preferences)} préférences trouvées", log_levels=log_levels)

        return preferences

    def write_prefs_file(self, path: Union[str, Path], prefs: Dict[str, Any], backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Écrit un dictionnaire de préférences dans un fichier prefs.js ou user.js.
        Préserve le formatage exact des valeurs.
        """
        file_path = Path(path) if isinstance(path, str) else path
        self.log_debug(f"Écriture du fichier de préférences: {file_path}", log_levels=log_levels)

        # Entête du fichier
        header = """// Mozilla User Preferences

    // DO NOT EDIT THIS FILE.
    //
    // If you make changes to this file while the application is running,
    // the changes will be overwritten when the application exits.
    //
    // To change a preference value, you can either:
    // - modify it via the UI (e.g. via about:config in the browser); or
    // - set it within a user.js file in your profile.

    """

        # Formater les préférences
        pref_lines = []
        for key, value in sorted(prefs.items()):
            formatted_value = self._format_pref_value(value)
            pref_lines.append(f'user_pref("{key}", {formatted_value});')

        # Assembler le contenu
        content = header + "\n".join(pref_lines) + "\n"

        # Écrire le fichier
        success = self._write_file_content(file_path, content, backup=backup)

        # Mettre à jour le cache si l'écriture réussit
        if success:
            self._pref_cache[str(file_path)] = prefs.copy()
            self.log_success(f"Fichier de préférences écrit avec succès: {len(prefs)} préférences", log_levels=log_levels)
        else:
            self.log_error(f"Échec de l'écriture du fichier de préférences: {file_path}", log_levels=log_levels)

        return success

    def get_pref(self, path: Union[str, Path], pref_name: str, default: Any = None, log_levels: Optional[Dict[str, str]] = None) -> Any:
        """
        Récupère une préférence spécifique d'un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences
            pref_name: Nom de la préférence à récupérer
            default: Valeur par défaut si la préférence n'existe pas

        Returns:
            Any: Valeur de la préférence ou valeur par défaut
        """
        prefs = self.read_prefs_file(path)
        if prefs is None:
            return default

        return prefs.get(pref_name, default)

    def set_pref(self, path: Union[str, Path], pref_name: str, value: Any, backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Définit une préférence dans un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences
            pref_name: Nom de la préférence à définir
            value: Nouvelle valeur de la préférence
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si la modification réussit, False sinon
        """
        # Lire les préférences existantes
        prefs = self.read_prefs_file(path)
        if prefs is None:
            # Si le fichier n'existe pas, créer un nouveau dictionnaire
            prefs = {}

        # Mettre à jour la préférence
        prefs[pref_name] = value

        # Écrire les préférences mises à jour
        return self.write_prefs_file(path, prefs, backup=backup)

    def remove_pref(self, path: Union[str, Path], pref_name: str, backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Supprime une préférence d'un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences
            pref_name: Nom de la préférence à supprimer
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si la suppression réussit, False sinon
        """
        # Lire les préférences existantes
        prefs = self.read_prefs_file(path)
        if prefs is None:
            return False

        # Vérifier si la préférence existe
        if pref_name not in prefs:
            self.log_warning(f"La préférence '{pref_name}' n'existe pas dans {path}", log_levels=log_levels)
            return True  # Considéré comme un succès puisque le résultat est le même

        # Supprimer la préférence
        del prefs[pref_name]

        # Écrire les préférences mises à jour
        return self.write_prefs_file(path, prefs, backup=backup)

    def get_prefs_by_prefix(self, path: Union[str, Path], prefix: str, log_levels: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """
        Récupère toutes les préférences dont le nom commence par un préfixe spécifique.

        Args:
            path: Chemin du fichier de préférences
            prefix: Préfixe des noms de préférences à récupérer

        Returns:
            Dict[str, Any]: Dictionnaire des préférences filtrées {nom: valeur}
        """
        prefs = self.read_prefs_file(path)
        if prefs is None:
            return {}

        # Filtrer les préférences par préfixe
        return {key: value for key, value in prefs.items() if key.startswith(prefix)}

    def set_multiple_prefs(self, path: Union[str, Path], prefs_to_set: Dict[str, Any], backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Définit plusieurs préférences en une seule opération.

        Args:
            path: Chemin du fichier de préférences
            prefs_to_set: Dictionnaire des préférences à définir {nom: valeur}
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si la modification réussit, False sinon
        """
        # Lire les préférences existantes
        prefs = self.read_prefs_file(path)
        if prefs is None:
            # Si le fichier n'existe pas, créer un nouveau dictionnaire
            prefs = {}

        # Mettre à jour les préférences
        prefs.update(prefs_to_set)

        # Écrire les préférences mises à jour
        return self.write_prefs_file(path, prefs, backup=backup)

    def find_profile_path(self, app_name: str = "thunderbird", profile_name: Optional[str] = None, log_levels: Optional[Dict[str, str]] = None) -> Optional[Path]:
        """
        Trouve le chemin d'un profil Mozilla.

        Args:
            app_name: Nom de l'application ("thunderbird" ou "firefox")
            profile_name: Nom du profil à rechercher ou None pour utiliser le profil par défaut

        Returns:
            Optional[Path]: Chemin du profil ou None si non trouvé
        """
        # Chemins possibles du dossier de profils selon l'OS
        if os.name == 'nt':  # Windows
            base_dirs = [
                os.path.expandvars(r'%APPDATA%\Mozilla\{app_name}\Profiles'),
                os.path.expandvars(r'%APPDATA%\{app_name}\Profiles')
            ]
        else:  # Linux/Unix/MacOS
            base_dirs = [
                os.path.expanduser(f'~/.{app_name}/Profiles'),
                os.path.expanduser(f'~/.mozilla/{app_name}/Profiles')
            ]

        # Remplacer {app_name} par le nom d'application réel
        base_dirs = [d.format(app_name=app_name) for d in base_dirs]

        # Chercher le fichier profiles.ini
        ini_paths = []
        for base_dir in base_dirs:
            parent_dir = os.path.dirname(base_dir)
            ini_path = os.path.join(parent_dir, 'profiles.ini')
            if os.path.isfile(ini_path):
                ini_paths.append(ini_path)

        # Analyser les fichiers profiles.ini trouvés
        for ini_path in ini_paths:
            try:
                config = configparser.ConfigParser()
                config.read(ini_path)

                # Chercher les sections de profil (Profile0, Profile1, etc.)
                for section in config.sections():
                    if section.startswith('Profile'):
                        # Vérifier si c'est le profil par défaut ou celui spécifié
                        if (profile_name is None and config.getboolean(section, 'Default', fallback=False)) or \
                           (profile_name is not None and config.get(section, 'Name', fallback='') == profile_name):

                            # Obtenir le chemin du profil
                            if config.getboolean(section, 'IsRelative', fallback=True):
                                # Chemin relatif au dossier parent de profiles.ini
                                profile_path = os.path.join(os.path.dirname(ini_path),
                                                           config.get(section, 'Path'))
                            else:
                                # Chemin absolu
                                profile_path = config.get(section, 'Path')

                            if os.path.isdir(profile_path):
                                self.log_debug(f"Profil {app_name} trouvé: {profile_path}", log_levels=log_levels)
                                return Path(profile_path)

            except (configparser.Error, IOError) as e:
                self.log_warning(f"Erreur lors de la lecture de {ini_path}: {e}", log_levels=log_levels)

        self.log_warning(f"Aucun profil {app_name} trouvé" +
                        (f" avec le nom '{profile_name}'" if profile_name else ""), log_levels=log_levels)
        return None

    def backup_prefs_file(self, path: Union[str, Path], log_levels: Optional[Dict[str, str]] = None) -> Optional[str]:
        """
        Crée une sauvegarde d'un fichier de préférences.

        Args:
            path: Chemin du fichier de préférences

        Returns:
            Optional[str]: Chemin de la sauvegarde ou None en cas d'erreur
        """
        file_path = Path(path) if isinstance(path, str) else path
        if not file_path.exists():
            self.log_warning(f"Fichier {file_path} non trouvé, impossible de créer une sauvegarde", log_levels=log_levels)
            return None

        # Créer un nom de fichier de sauvegarde avec timestamp
        backup_path = f"{file_path}.bak.{int(time.time())}"

        try:
            shutil.copy2(file_path, backup_path)
            self.log_debug(f"Sauvegarde créée: {backup_path}", log_levels=log_levels)
            return backup_path
        except Exception as e:
            self.log_error(f"Erreur lors de la création de la sauvegarde: {e}", log_levels=log_levels)
            return None

    def read_prefs_file(self, path: Union[str, Path], log_levels: Optional[Dict[str, str]] = None) -> Optional[Dict[str, Any]]:
        """
        Lit un fichier de préférences Mozilla (prefs.js ou user.js).

        Args:
            path: Chemin du fichier de préférences

        Returns:
            Optional[Dict[str, Any]]: Dictionnaire des préférences {nom: valeur} ou None en cas d'erreur
        """
        file_path = Path(path) if isinstance(path, str) else path
        self.log_debug(f"Lecture du fichier de préférences: {file_path}", log_levels=log_levels)

        # Vérifier si les préférences sont déjà en cache
        cache_key = str(file_path)
        if cache_key in self._pref_cache:
            self.log_debug(f"Utilisation des préférences en cache pour {file_path}", log_levels=log_levels)
            return self._pref_cache[cache_key].copy()

        # Lire le contenu du fichier
        content = self._read_file_content(file_path)
        if content is None:
            return None

        preferences = {}
        # Utiliser une expression régulière pour extraire les préférences correctement
        pref_pattern = re.compile(r'user_pref\("([^"]+)",\s*(.*?)\);')

        for match in pref_pattern.finditer(content):
            key = match.group(1)
            value_str = match.group(2).strip()
            # Conserver la valeur exactement comme elle apparaît dans le fichier
            # pour les structures complexes
            try:
                value = self._convert_pref_value(value_str)
                preferences[key] = value
            except Exception as e:
                self.log_warning(f"Erreur lors de la conversion de la valeur pour {key}: {e}", log_levels=log_levels)
                # Conserver la valeur brute en cas d'erreur
                preferences[key] = value_str

        # Mettre en cache les préférences lues
        self._pref_cache[cache_key] = preferences.copy()
        self.log_debug(f"Fichier de préférences lu: {len(preferences)} préférences trouvées", log_levels=log_levels)

        return preferences


    def read_policies_json(self, path: Union[str, Path], log_levels: Optional[Dict[str, str]] = None) -> Optional[Dict[str, Any]]:
        """
        Lit un fichier policies.json de Mozilla.

        Args:
            path: Chemin du fichier policies.json

        Returns:
            Optional[Dict[str, Any]]: Structure de politiques ou None en cas d'erreur
        """
        file_path = Path(path) if isinstance(path, str) else path
        self.log_debug(f"Lecture du fichier policies.json: {file_path}", log_levels=log_levels)

        # Lire le contenu du fichier
        content = self._read_file_content(file_path)
        if content is None:
            return None

        try:
            # Parser le JSON
            policies = json.loads(content)
            self.log_debug(f"Fichier policies.json lu avec succès: {len(policies)} éléments", log_levels=log_levels)
            return policies
        except json.JSONDecodeError as e:
            self.log_error(f"Erreur JSON dans {file_path}: {e}", log_levels=log_levels)
            return None
        except Exception as e:
            self.log_error(f"Erreur lors de la lecture de policies.json: {e}", log_levels=log_levels)
            return None

    def write_policies_json(self, path: Union[str, Path], policies: Dict[str, Any],
backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Écrit un dictionnaire de politiques dans un fichier policies.json.

        Args:
            path: Chemin du fichier policies.json
            policies: Dictionnaire des politiques
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'écriture réussit, False sinon
        """
        file_path = Path(path) if isinstance(path, str) else path
        self.log_debug(f"Écriture du fichier policies.json: {file_path}", log_levels=log_levels)

        try:
            # Formater le JSON
            content = json.dumps(policies, indent=2)

            # Écrire le fichier
            return self._write_file_content(file_path, content, backup=backup)
        except Exception as e:
            self.log_error(f"Erreur lors de l'écriture de policies.json: {e}", log_levels=log_levels)
            return False

    def configure_firefox_enterprise_policies(self, policies: Dict[str, Any],
install_dir: Optional[Union[str, Path]] = None, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Configure les politiques d'entreprise pour Firefox.

        Args:
            policies: Dictionnaire des politiques à configurer
            install_dir: Répertoire d'installation de Firefox ou None pour utiliser l'emplacement par défaut

        Returns:
            bool: True si la configuration réussit, False sinon
        """
        # Déterminer le répertoire d'installation
        if install_dir is None:
            if os.name == 'nt':  # Windows
                possible_paths = [
                    r'C:\Program Files\Mozilla Firefox',
                    r'C:\Program Files (x86)\Mozilla Firefox'
                ]
            else:  # Linux/Unix/MacOS
                possible_paths = [
                    '/usr/lib/firefox',
                    '/usr/lib64/firefox',
                    '/opt/firefox'
                ]

            # Trouver le premier chemin existant
            install_dir = next((p for p in possible_paths if os.path.isdir(p)), None)

            if install_dir is None:
                self.log_error("Répertoire d'installation Firefox non trouvé", log_levels=log_levels)
                return False

        install_dir = Path(install_dir) if isinstance(install_dir, str) else install_dir

        # Créer le répertoire de distribution si nécessaire
        distribution_dir = install_dir / 'distribution'
        os.makedirs(distribution_dir, exist_ok=True)

        # Chemin du fichier policies.json
        policies_path = distribution_dir / 'policies.json'

        # Préparer la structure des politiques
        policies_json = {
            "policies": policies
        }

        # Écrire le fichier policies.json
        return self.write_policies_json(policies_path, policies_json)

    def read_cfg_file(self, path: Union[str, Path], log_levels: Optional[Dict[str, str]] = None) -> Optional[Dict[str, Dict[str, Any]]]:
        """
        Lit un fichier .cfg de Mozilla (format similaire à prefs.js mais avec lockPref, etc.).

        Args:
            path: Chemin du fichier .cfg

        Returns:
            Optional[Dict[str, Dict[str, Any]]]: Dictionnaire des préférences ou None en cas d'erreur
        """
        file_path = Path(path) if isinstance(path, str) else path
        self.log_debug(f"Lecture du fichier .cfg: {file_path}", log_levels=log_levels)

        # Lire le contenu du fichier
        content = self._read_file_content(file_path)
        if content is None:
            return None

        # Analyse du fichier .cfg
        prefs = {}

        # Patterns pour les différents types de préférences
        lock_pattern = re.compile(r'lockPref\("([^"]+)",\s*(.*?)\);')
        default_pattern = re.compile(r'defaultPref\("([^"]+)",\s*(.*?)\);')
        pref_pattern = re.compile(r'pref\("([^"]+)",\s*(.*?)\);')

        # Rechercher les préférences verrouillées
        for match in lock_pattern.finditer(content):
            key = match.group(1)
            value_str = match.group(2).strip()
            value = self._convert_pref_value(value_str)
            prefs[key] = {"value": value, "type": "lockPref"}

        # Rechercher les préférences par défaut
        for match in default_pattern.finditer(content):
            key = match.group(1)
            value_str = match.group(2).strip()
            value = self._convert_pref_value(value_str)
            # Ne pas écraser les lockPref s'ils existent déjà
            if key not in prefs:
                prefs[key] = {"value": value, "type": "defaultPref"}

        # Rechercher les préférences normales
        for match in pref_pattern.finditer(content):
            key = match.group(1)
            value_str = match.group(2).strip()
            value = self._convert_pref_value(value_str)
            # Ne pas écraser les lockPref ou defaultPref s'ils existent déjà
            if key not in prefs:
                prefs[key] = {"value": value, "type": "pref"}

        self.log_debug(f"Fichier .cfg lu: {len(prefs)} préférences trouvées", log_levels=log_levels)
        return prefs

    def write_cfg_file(self, path: Union[str, Path], prefs: Dict[str, Dict[str, Any]],
backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Écrit un dictionnaire de préférences dans un fichier .cfg.

        Args:
            path: Chemin du fichier .cfg
            prefs: Dictionnaire des préférences {nom: {value: value, type: lockPref|defaultPref}}
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'écriture réussit, False sinon
        """
        file_path = Path(path) if isinstance(path, str) else path
        self.log_debug(f"Écriture du fichier .cfg: {file_path}", log_levels=log_levels)

        # Regrouper par type de préférence
        lock_prefs = []
        default_prefs = []
        normal_prefs = []

        for key, data in sorted(prefs.items()):
            value = data["value"]
            pref_type = data.get("type", "pref")
            formatted_value = self._format_pref_value(value)

            if pref_type == "lockPref":
                lock_prefs.append(f'lockPref("{key}", {formatted_value});')
            elif pref_type == "defaultPref":
                default_prefs.append(f'defaultPref("{key}", {formatted_value});')
            else:
                normal_prefs.append(f'pref("{key}", {formatted_value});')

        # Assembler le contenu
        content = "// Mozilla Configuration File\n\n"

        if lock_prefs:
            content += "// Locked Preferences\n"
            content += "\n".join(lock_prefs) + "\n\n"

        if default_prefs:
            content += "// Default Preferences\n"
            content += "\n".join(default_prefs) + "\n\n"

        if normal_prefs:
            content += "// Regular Preferences\n"
            content += "\n".join(normal_prefs) + "\n\n"

        # Écrire le fichier
        return self._write_file_content(file_path, content, backup=backup)

    def add_lockpref_to_cfg(self, path: Union[str, Path], pref_name: str, value: Any,
backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Ajoute une préférence verrouillée à un fichier .cfg.

        Args:
            path: Chemin du fichier .cfg
            pref_name: Nom de la préférence à verrouiller
            value: Valeur de la préférence
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'ajout réussit, False sinon
        """
        # Lire les préférences existantes
        prefs = self.read_cfg_file(path)
        if prefs is None:
            prefs = {}

        # Ajouter ou mettre à jour la préférence verrouillée
        prefs[pref_name] = {"value": value, "type": "lockPref"}

        # Écrire les préférences mises à jour
        return self.write_cfg_file(path, prefs, backup=backup)

    def add_defaultpref_to_cfg(self, path: Union[str, Path], pref_name: str, value: Any,
backup: bool = True, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Ajoute une préférence par défaut à un fichier .cfg.

        Args:
            path: Chemin du fichier .cfg
            pref_name: Nom de la préférence par défaut
            value: Valeur de la préférence
            backup: Si True, crée une sauvegarde du fichier original

        Returns:
            bool: True si l'ajout réussit, False sinon
        """
        # Lire les préférences existantes
        prefs = self.read_cfg_file(path)
        if prefs is None:
            prefs = {}

        # Ajouter ou mettre à jour la préférence par défaut (sauf si déjà verrouillée)
        if pref_name not in prefs or prefs[pref_name]["type"] != "lockPref":
            prefs[pref_name] = {"value": value, "type": "defaultPref"}

        # Écrire les préférences mises à jour
        return self.write_cfg_file(path, prefs, backup=backup)

    def configure_autoconfig(self, install_dir: Optional[Union[str, Path]] = None, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Configure l'autoconfiguration pour Firefox ou Thunderbird.

        Args:
            install_dir: Répertoire d'installation ou None pour utiliser l'emplacement par défaut

        Returns:
            bool: True si la configuration réussit, False sinon
        """
        # Cette méthode nécessiterait une implémentation spécifique selon vos besoins
        # Elle devrait créer/modifier les fichiers autoconfig.js et mozilla.cfg
        self.log_warning("Méthode configure_autoconfig non implémentée", log_levels=log_levels)
        return False

    def get_thunderbird_account_settings(self, profile_path: Optional[Union[str, Path]] = None, log_levels: Optional[Dict[str, str]] = None) -> Dict[str, Dict[str, Any]]:
        """
        Récupère les paramètres de compte Thunderbird à partir du fichier prefs.js.

        Args:
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            Dict[str, Dict[str, Any]]: Structure des paramètres de compte
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path(app_name="thunderbird")
            if profile_path is None:
                return {}

        profile_path = Path(profile_path) if isinstance(profile_path, str) else profile_path

        # Lire le fichier prefs.js
        prefs_path = profile_path / "prefs.js"
        prefs = self.read_prefs_file(prefs_path)
        if prefs is None:
            return {}

        # Récupérer la liste des comptes
        accounts = prefs.get("mail.accountmanager.accounts", "").split(",")
        default_account = prefs.get("mail.accountmanager.defaultaccount", "")

        # Structure pour stocker les informations de compte
        account_settings = {
            "accounts": accounts,
            "default_account": default_account,
            "account_details": {}
        }

        # Extraire les détails de chaque compte
        for account in accounts:
            if not account:
                continue

            account_data = {}

            # Récupérer les identités associées à ce compte
            identities = prefs.get(f"mail.account.{account}.identities", "").split(",")
            account_data["identities"] = identities

            # Récupérer le serveur associé à ce compte
            server_id = prefs.get(f"mail.account.{account}.server", "")
            account_data["server"] = server_id

            # Extraire les détails de l'identité et du serveur
            account_data["identity_details"] = {}
            account_data["server_details"] = {}

            # Parcourir toutes les préférences pour trouver celles liées à ce compte
            for key, value in prefs.items():
                # Détails de l'identité
                for identity in identities:
                    if key.startswith(f"mail.identity.{identity}."):
                        identity_key = key[len(f"mail.identity.{identity}."):]
                        if identity not in account_data["identity_details"]:
                            account_data["identity_details"][identity] = {}
                        account_data["identity_details"][identity][identity_key] = value

                # Détails du serveur
                if server_id and key.startswith(f"mail.server.{server_id}."):
                    server_key = key[len(f"mail.server.{server_id}."):]
                    account_data["server_details"][server_key] = value

            # Ajouter les détails de ce compte à la structure principale
            account_settings["account_details"][account] = account_data

        return account_settings

    def set_thunderbird_account_setting(self, account_id: str, setting_type: str, setting_id: str,
                                       key: str, value: Any,
profile_path: Optional[Union[str, Path]] = None, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Définit un paramètre de compte Thunderbird.

        Args:
            account_id: ID du compte (ex: "account1")
            setting_type: Type de paramètre ("identity" ou "server")
            setting_id: ID du paramètre (ex: "id1" pour identity, "server1" pour server)
            key: Clé du paramètre (ex: "useremail" pour identity, "hostname" pour server)
            value: Nouvelle valeur du paramètre
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            bool: True si la modification réussit, False sinon
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path(app_name="thunderbird")
            if profile_path is None:
                self.log_error("Profil Thunderbird non trouvé", log_levels=log_levels)
                return False

        profile_path = Path(profile_path) if isinstance(profile_path, str) else profile_path

        # Lire le fichier prefs.js
        prefs_path = profile_path / "prefs.js"

        # Construire la clé complète selon le type de paramètre
        if setting_type == "identity":
            full_key = f"mail.identity.{setting_id}.{key}"
        elif setting_type == "server":
            full_key = f"mail.server.{setting_id}.{key}"
        else:
            self.log_error(f"Type de paramètre non reconnu: {setting_type}", log_levels=log_levels)
            return False

        # Définir la préférence
        return self.set_pref(prefs_path, full_key, value)

    def configure_thunderbird_proxy(self, proxy_type: str, proxy_host: str, proxy_port: int,
profile_path: Optional[Union[str, Path]] = None, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Configure les paramètres de proxy pour Thunderbird.

        Args:
            proxy_type: Type de proxy ("none", "manual", "auto")
            proxy_host: Hôte du proxy (pour "manual")
            proxy_port: Port du proxy (pour "manual")
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            bool: True si la configuration réussit, False sinon
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path(app_name="thunderbird")
            if profile_path is None:
                self.log_error("Profil Thunderbird non trouvé", log_levels=log_levels)
                return False

        profile_path = Path(profile_path) if isinstance(profile_path, str) else profile_path

        # Lire le fichier prefs.js
        prefs_path = profile_path / "prefs.js"

        # Préférences à définir selon le type de proxy
        proxy_prefs = {}

        if proxy_type == "none":
            proxy_prefs["network.proxy.type"] = 0
        elif proxy_type == "manual":
            proxy_prefs["network.proxy.type"] = 1
            proxy_prefs["network.proxy.http"] = proxy_host
            proxy_prefs["network.proxy.http_port"] = proxy_port
            proxy_prefs["network.proxy.ssl"] = proxy_host
            proxy_prefs["network.proxy.ssl_port"] = proxy_port
            proxy_prefs["network.proxy.ftp"] = proxy_host
            proxy_prefs["network.proxy.ftp_port"] = proxy_port
            proxy_prefs["network.proxy.socks"] = proxy_host
            proxy_prefs["network.proxy.socks_port"] = proxy_port
        elif proxy_type == "auto":
            proxy_prefs["network.proxy.type"] = 2
        else:
            self.log_error(f"Type de proxy non reconnu: {proxy_type}", log_levels=log_levels)
            return False

        # Définir les préférences
        return self.set_multiple_prefs(prefs_path, proxy_prefs)

    def configure_thunderbird_filters(self, filters: List[Dict[str, Any]],
profile_path: Optional[Union[str, Path]] = None, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Configure les filtres de messagerie pour Thunderbird.

        Args:
            filters: Liste des filtres à configurer
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            bool: True si la configuration réussit, False sinon
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path(app_name="thunderbird")
            if profile_path is None:
                self.log_error("Profil Thunderbird non trouvé", log_levels=log_levels)
                return False

        profile_path = Path(profile_path) if isinstance(profile_path, str) else profile_path

        # Cette méthode nécessiterait une implémentation plus complexe
        # Les filtres sont stockés dans un format spécifique dans msgFilterRules.dat
        self.log_warning("Méthode configure_thunderbird_filters non complètement implémentée", log_levels=log_levels)

        # Implémentation simplifiée (pourrait ne pas fonctionner dans tous les cas)
        try:
            # Écrire les filtres dans un format JSON pour les retrouver plus tard
            filters_json_path = profile_path / "custom_filters.json"
            with open(filters_json_path, 'w', encoding='utf-8') as f:
                json.dump(filters, f, indent=2)

            return True
        except Exception as e:
            self.log_error(f"Erreur lors de la configuration des filtres: {e}", log_levels=log_levels)
            return False

    def update_lightning_calendar(self, ics_url: str, name: str, color: str = "#3366CC",
profile_path: Optional[Union[str, Path]] = None, log_levels: Optional[Dict[str, str]] = None) -> bool:
        """
        Ajoute ou met à jour un calendrier Lightning dans Thunderbird.

        Args:
            ics_url: URL du calendrier ICS
            name: Nom du calendrier
            color: Couleur du calendrier au format hexadécimal
            profile_path: Chemin du profil Thunderbird ou None pour le rechercher automatiquement

        Returns:
            bool: True si la configuration réussit, False sinon
        """
        # Trouver le chemin du profil si non spécifié
        if profile_path is None:
            profile_path = self.find_profile_path(app_name="thunderbird")
            if profile_path is None:
                self.log_error("Profil Thunderbird non trouvé", log_levels=log_levels)
                return False

        profile_path = Path(profile_path) if isinstance(profile_path, str) else profile_path

        # Lire le fichier prefs.js
        prefs_path = profile_path / "prefs.js"
        prefs = self.read_prefs_file(prefs_path)
        if prefs is None:
            self.log_error(f"Impossible de lire le fichier prefs.js: {prefs_path}", log_levels=log_levels)
            return False

        # Générer un ID unique pour le calendrier
        calendar_id = str(uuid.uuid4())

        # Préférences à définir pour ce calendrier
        calendar_prefs = {
            f"calendar.registry.{calendar_id}.calendar-main-in-composite": True,
            f"calendar.registry.{calendar_id}.color": color,
            f"calendar.registry.{calendar_id}.disabled": False,
            f"calendar.registry.{calendar_id}.name": name,
            f"calendar.registry.{calendar_id}.type": "ics",
            f"calendar.registry.{calendar_id}.uri": ics_url,
            f"calendar.registry.{calendar_id}.refreshInterval": 30  # Rafraîchir toutes les 30 minutes
        }

        # Mettre à jour la liste des calendriers
        current_calendars = prefs.get("calendar.list.sortOrder", "").split()
        if calendar_id not in current_calendars:
            current_calendars.append(calendar_id)
            calendar_prefs["calendar.list.sortOrder"] = " ".join(current_calendars)

        # Définir les préférences
        return self.set_multiple_prefs(prefs_path, calendar_prefs)

    # Méthodes utilitaires privées

    def _convert_pref_value(self, value_str: str) -> Any:
        """
        Convertit une valeur de préférence en format string vers son type Python approprié.
        Préserve les caractères d'échappement dans les chaînes.
        """
        # Valeur booléenne
        if value_str.lower() == "true":
            return True
        elif value_str.lower() == "false":
            return False

        # Nombre entier
        try:
            if value_str.isdigit() or (value_str.startswith('-') and value_str[1:].isdigit()):
                return int(value_str)
        except ValueError:
            pass

        # Nombre décimal
        try:
            if '.' in value_str and not value_str.startswith('"') and not value_str.endswith('"'):
                return float(value_str)
        except ValueError:
            pass

        # Chaîne de caractères (avec guillemets)
        if (value_str.startswith('"') and value_str.endswith('"')) or \
        (value_str.startswith("'") and value_str.endswith("'")):
            # Supprimer les guillemets mais conserver le texte exact à l'intérieur
            raw_value = value_str[1:-1]
            # Stocker la valeur brute avec ses échappements
            return {"_raw_value": True, "value": raw_value}

        # Autres valeurs (laisser telles quelles)
        return value_str

    def _format_pref_value(self, value: Any) -> str:
        """
        Formate une valeur Python pour l'écriture dans un fichier de préférences.
        Préserve le formatage exact des chaînes avec échappements.
        """
        if value is None:
            return "null"

        if isinstance(value, bool):
            return "true" if value else "false"

        if isinstance(value, (int, float)):
            return str(value)

        # Si c'est une valeur brute préservée (avec les échappements d'origine)
        if isinstance(value, dict) and "_raw_value" in value:
            return f'"{value["value"]}"'

        if isinstance(value, str):
            # Pour les autres chaînes, échapper normalement
            escaped_value = value.replace('\\', '\\\\').replace('"', '\\"')
            return f'"{escaped_value}"'

        # Pour les autres types, convertir en JSON
        return json.dumps(value)